<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>python网站目录扫描</title>
      <link href="/2022/05/12/python%E7%BD%91%E7%AB%99%E7%9B%AE%E5%BD%95%E6%89%AB%E6%8F%8F/"/>
      <url>/2022/05/12/python%E7%BD%91%E7%AB%99%E7%9B%AE%E5%BD%95%E6%89%AB%E6%8F%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="使用python实现网站目录的扫描："><a href="#使用python实现网站目录的扫描：" class="headerlink" title="使用python实现网站目录的扫描："></a>使用python实现网站目录的扫描：</h1><h2 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h2><p>用户再输入网站url时出现如果输入正确网站的状态码为200，反之则错误，如果我们知道一个网站，则可以在后面拼接url参数扫描其文件目录，根据网站状态码判断网站是否存在改文件。</p><h2 id="python思路："><a href="#python思路：" class="headerlink" title="python思路："></a>python思路：</h2><p>从外部打开字典文件，与网站url进行拼接组成新的url，再对url进行requests请求，判断网页状态码。if判断，若出现200状态码则输出url，反正则继续拼接url发送请求。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ctf中的加密</title>
      <link href="/2022/05/09/CTF-misc%E4%B8%AD%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86/"/>
      <url>/2022/05/09/CTF-misc%E4%B8%AD%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="ZIP伪加密："><a href="#ZIP伪加密：" class="headerlink" title="ZIP伪加密："></a>ZIP伪加密：</h1><p>​在做misc题时，经常会遇见压缩包，新手容易会去直接爆破拿密码或者其他方式寻找压缩包的密码，此时就容易陷入做题的误区。</p><p>如ctfshow中有这样一道题：</p><p><img src="https://i.bmp.ovh/imgs/2022/05/10/40119a77437174dc.png" class="lazyload placeholder" data-srcset="https://i.bmp.ovh/imgs/2022/05/10/40119a77437174dc.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p>打开文件提升忘记密码了，尝试爆破后无效，查看其余地方也没有提升。此时我们考虑文件本身的问题。拖入winhex打开发现：</p><p><img src="https://s3.bmp.ovh/imgs/2022/05/10/25448b01fc8440c3.png" class="lazyload placeholder" data-srcset="https://s3.bmp.ovh/imgs/2022/05/10/25448b01fc8440c3.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p>50 4B 01 02：文件头标记</p><p>09 00：文件加密属性，奇数为有加密，偶数则无加密。</p><p>这里我们只需将09改为00即可</p><p>此时打开就没有提升加密了。</p><p><img src="https://s3.bmp.ovh/imgs/2022/05/10/c99a1a6851e54dfa.png" class="lazyload placeholder" data-srcset="https://s3.bmp.ovh/imgs/2022/05/10/c99a1a6851e54dfa.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p>当然我们也可以使用工具ZipCenOp。</p><p><img src="https://s3.bmp.ovh/imgs/2022/05/10/7a226e684391d770.png" class="lazyload placeholder" data-srcset="https://s3.bmp.ovh/imgs/2022/05/10/7a226e684391d770.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p>使用之后的压缩包就没有密码啦。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入知识点总结</title>
      <link href="/2022/04/19/SQL%E6%B3%A8%E5%85%A5%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2022/04/19/SQL%E6%B3%A8%E5%85%A5%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL注入？？？"><a href="#SQL注入？？？" class="headerlink" title="SQL注入？？？"></a>SQL注入？？？</h1><p>SQL注入即是指<a href="https://baike.baidu.com/item/web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/2498090">web应用程序</a>对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的<a href="https://baike.baidu.com/item/SQL%E8%AF%AD%E5%8F%A5/5714895">SQL语句</a>，在管理员不知情的情况下实现非法操作，以此来实现欺骗<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8/613818">数据库服务器</a>执行非授权的任意查询，从而进一步得到相应的数据信息。——百度百科</p><h2 id="语法详解："><a href="#语法详解：" class="headerlink" title="语法详解："></a>语法详解：</h2><p>在注入过程中我们经常使用单引号和#构造闭合，此语法呢可以使我们的sql语句能够被执行比如此处：</p><p><a href="https://imgtu.com/i/LoJWjK"><img src="https://s1.ax1x.com/2022/04/25/LoJWjK.png" class="lazyload placeholder" data-srcset="https://s1.ax1x.com/2022/04/25/LoJWjK.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="LoJWjK.png"></a></p><p>原先的语法会查询用户输入的参数，但是使用单引号进行闭合之后，会执行以下sql查询的语句：</p><p><a href="https://imgtu.com/i/LoJ6hR"><img src="https://s1.ax1x.com/2022/04/25/LoJ6hR.png" class="lazyload placeholder" data-srcset="https://s1.ax1x.com/2022/04/25/LoJ6hR.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="LoJ6hR.png"></a></p><p>在MySQL中只能同时执行一个语句，于是我们使用联合查询语句union拼接SQL语句，再使用#注释掉后面语句。构造出基本的SQL注入语句</p><h2 id="SQL注入几大方式："><a href="#SQL注入几大方式：" class="headerlink" title="SQL注入几大方式："></a>SQL注入几大方式：</h2><h3 id="get型注入"><a href="#get型注入" class="headerlink" title="get型注入"></a>get型注入</h3><p>网站在传递参数时直接将参数使用get提交，此时可以直接构造闭合使用查询语法：</p><p><img src="C:\Users\THR\AppData\Roaming\Typora\typora-user-images\image-20220424200635259.png" class="lazyload placeholder" data-srcset="C:\Users\THR\AppData\Roaming\Typora\typora-user-images\image-20220424200635259.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220424200635259"></p><p>此时网站没有过滤，直接执行了sql语句，于是造成在注入攻击事件的发生。</p><p><a href="https://imgtu.com/i/LoJJts"><img src="https://s1.ax1x.com/2022/04/25/LoJJts.png" class="lazyload placeholder" data-srcset="https://s1.ax1x.com/2022/04/25/LoJJts.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="LoJJts.png"></a></p><h3 id="post型注入："><a href="#post型注入：" class="headerlink" title="post型注入："></a>post型注入：</h3><p>许多网站在与数据库交互的时候并没有使用搜索框输入框进行查询。但是提供了一些查询按钮，此时网页相当于使用post提交表单数据。我们可以考虑抓包直接修改其数据。如皮卡丘靶场中就提供了这样的一个案例：</p><p><img src="https://s1.ax1x.com/2022/04/25/LoGQo9.png" class="lazyload placeholder" data-srcset="https://s1.ax1x.com/2022/04/25/LoGQo9.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="LoGQo9.png (709×324) (ax1x.com)"></p><p>可以看到他只有一个选择查询的按钮，并且，在url上也没有其余的改变。</p><p><img src="https://s1.ax1x.com/2022/04/25/Lo8BvT.png" class="lazyload placeholder" data-srcset="https://s1.ax1x.com/2022/04/25/Lo8BvT.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="Lo8BvT.png (1553×393) (ax1x.com)"></p><p>我们只需要直接修改其表单内容，就可以做到与get相同的查询效果。</p><h3 id="盲注："><a href="#盲注：" class="headerlink" title="盲注："></a>盲注：</h3><h4 id="布尔盲注："><a href="#布尔盲注：" class="headerlink" title="布尔盲注："></a>布尔盲注：</h4><p>在注入页面中没有回显，页面没有提供具体信息，只有true和false两种状态，但是代码语句依然是可以被执行表达的，此时我们就称它为布尔盲注。</p><p>如图，我们使用查询语法’ length(database())&gt;&#x3D;7 #判断库名长度时出现了正确的结果。</p><p><img src="https://s1.ax1x.com/2022/04/25/Lolf8f.png" class="lazyload placeholder" data-srcset="https://s1.ax1x.com/2022/04/25/Lolf8f.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="Lolf8f.png (1117×297) (ax1x.com)"></p><p>但是使用查询语句查询库长度大于7时则会报错。</p><p>如图：</p><p><img src="https://s1.ax1x.com/2022/04/25/LolFgS.png" class="lazyload placeholder" data-srcset="https://s1.ax1x.com/2022/04/25/LolFgS.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="LolFgS.png (1110×301) (ax1x.com)"></p><p>此时我们就可以判断出数据库名大于等于7</p><p>然后在使用数据库名查询语法：lucy’ and ascii(substr(database(),{},1))&#x3D;{}#</p><p>挨个查询数据库中的字母判断是否存在，若存在该字母会显示正常页面，不存在则会显示该用户不存在，于是我们可以编写python脚本测试出该网站的数据库名。<a href="https://imgtu.com/i/LotiIH"><img src="https://s1.ax1x.com/2022/04/25/LotiIH.png" class="lazyload placeholder" data-srcset="https://s1.ax1x.com/2022/04/25/LotiIH.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="LotiIH.png"></a></p><h4 id="时间盲注："><a href="#时间盲注：" class="headerlink" title="时间盲注："></a>时间盲注：</h4><p>有的网站，虽然会执行SQL的注入语句但是不会出现返回页面，单从网页也无法判断出注入结果。</p><p>此时我们可以构造出SQL语句时间延迟</p><p><a href="https://imgtu.com/i/LoR0KS"><img src="https://s1.ax1x.com/2022/04/25/LoR0KS.png" class="lazyload placeholder" data-srcset="https://s1.ax1x.com/2022/04/25/LoR0KS.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="LoR0KS.png"></a></p><p>此时如果查询有结果便会直接返回，如果不存在会延迟1秒执行，我们便可以根据时间延迟的程度，判断出该数据库的信息。</p><h3 id="搜索型注入："><a href="#搜索型注入：" class="headerlink" title="搜索型注入："></a>搜索型注入：</h3><p>搜索型注入的代码执行逻辑实际上和字符型一样，区别在于求闭合的方式，搜索型的查询语句为SELECT*from database.table where users like ‘%</p><p>此时我们需要使用%’来将sql语句闭合，然后再执行查询代码</p><p><a href="https://imgtu.com/i/LoBn9e"><img src="https://s1.ax1x.com/2022/04/25/LoBn9e.png" class="lazyload placeholder" data-srcset="https://s1.ax1x.com/2022/04/25/LoBn9e.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="LoBn9e.png"></a></p><p>如图，我们可以看到，实际上将语句闭合后再执行的语句和字符型注入的语句类似。</p><h3 id="XXX型注入："><a href="#XXX型注入：" class="headerlink" title="XXX型注入："></a>XXX型注入：</h3><p>xx型注入和搜索型类似，本质都是构造出闭合</p><p>在皮卡丘靶场中有xx注入的题：</p><p><a href="https://imgtu.com/i/Lofkk9"><img src="https://s1.ax1x.com/2022/04/25/Lofkk9.png" class="lazyload placeholder" data-srcset="https://s1.ax1x.com/2022/04/25/Lofkk9.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="Lofkk9.png"></a></p><p>查看代码，我们可以发现该页面查询语句为：</p><p><a href="https://imgtu.com/i/Lofd0g"><img src="https://s1.ax1x.com/2022/04/25/Lofd0g.png" class="lazyload placeholder" data-srcset="https://s1.ax1x.com/2022/04/25/Lofd0g.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="Lofd0g.png"></a></p><p>如果我们构造‘）则可以闭合语句，然后可以执行其余的代码：</p><p><a href="https://imgtu.com/i/Lof5N9"><img src="https://s1.ax1x.com/2022/04/25/Lof5N9.png" class="lazyload placeholder" data-srcset="https://s1.ax1x.com/2022/04/25/Lof5N9.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="Lof5N9.png"></a></p><p>如图，执行order by的代码语句是没有问题的。</p><h3 id="插入-x2F-更新注入："><a href="#插入-x2F-更新注入：" class="headerlink" title="插入&#x2F;更新注入："></a>插入&#x2F;更新注入：</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java面向对象（初级）</title>
      <link href="/2022/04/17/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%88%9D%E7%BA%A7%EF%BC%89/"/>
      <url>/2022/04/17/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%88%9D%E7%BA%A7%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象与面向过程："><a href="#面向对象与面向过程：" class="headerlink" title="面向对象与面向过程："></a>面向对象与面向过程：</h1><p>举个栗子：把大象放进冰箱需要几步？</p><p>面向过程：首先需要打开冰箱门，拿到大象放入冰箱，关闭冰箱门。此时需要写出每一步的方法。</p><p>面向对象：只需创造大象创造冰箱，告诉大象进入冰箱，聪明的大象会自己走到冰箱中去。（顺手再把冰箱门带上）</p><p>两者都可以实现相同的目的，但是对于程序设计者而言，面向对象更加方便。</p><p>但是面对具体情况有具体方法，二者在不同的情况下有不同的运用，没有必要纠结于哪个更好。</p><h2 id="Java中的面向对象："><a href="#Java中的面向对象：" class="headerlink" title="Java中的面向对象："></a>Java中的面向对象：</h2><p><img src="https://s3.bmp.ovh/imgs/2022/04/17/f3f0a42df2ad2e51.png" class="lazyload placeholder" data-srcset="https://s3.bmp.ovh/imgs/2022/04/17/f3f0a42df2ad2e51.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220417163657862"></p><h2 id="类与对象："><a href="#类与对象：" class="headerlink" title="类与对象："></a>类与对象：</h2><h3 id="对象是类的实例，类是对象的模板。"><a href="#对象是类的实例，类是对象的模板。" class="headerlink" title="对象是类的实例，类是对象的模板。"></a>对象是类的实例，类是对象的模板。</h3><h4 id="再次举个栗子：我想造一法拉利（为什么是法拉利，不是兰博基尼？因为法拉利做梦更容易梦到）"><a href="#再次举个栗子：我想造一法拉利（为什么是法拉利，不是兰博基尼？因为法拉利做梦更容易梦到）" class="headerlink" title="再次举个栗子：我想造一法拉利（为什么是法拉利，不是兰博基尼？因为法拉利做梦更容易梦到）"></a>再次举个栗子：我想造一法拉利（为什么是法拉利，不是兰博基尼？因为法拉利做梦更容易梦到）</h4><p>首先，我们需要知道这辆车的属性。</p><p>​也就是说这辆车是什么颜色，能坐几个人，能跑多快？</p><p>​<img src="https://pic.dogimg.com/2022/04/17/625bee3dd069f.png" class="lazyload placeholder" data-srcset="https://pic.dogimg.com/2022/04/17/625bee3dd069f.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220417183730614">)</p><p>比如这里，我定义了车的颜色，速度，座位，但是没有给他们赋值。</p><p>这里定义一个方法，说明了车可以跑但是不能飞，在我们下一次使用的时候可以调用该方法。</p><p><img src="https://pic.dogimg.com/2022/04/17/625beed77524f.png" class="lazyload placeholder" data-srcset="https://pic.dogimg.com/2022/04/17/625beed77524f.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220417184046425"></p><p>之后我们创建出对象，再调用该方法：</p><p><img src="https://pic.dogimg.com/2022/04/17/625befde0a601.png" class="lazyload placeholder" data-srcset="https://pic.dogimg.com/2022/04/17/625befde0a601.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220417184503359"></p><p>此时这个车便有了一个属性：“可以跑，但是不能飞”</p><p>之后我们再给车的属性赋值。</p><p>例如：</p><p><img src="https://pic.dogimg.com/2022/04/17/625bf0d474760.png" class="lazyload placeholder" data-srcset="https://pic.dogimg.com/2022/04/17/625bf0d474760.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220417184923086"></p><p>如此一来：我们便实现了面向对象思想的一个简单运用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python爬虫开发</title>
      <link href="/2022/04/14/python%E7%88%AC%E8%99%AB%E7%BC%96%E5%86%99/"/>
      <url>/2022/04/14/python%E7%88%AC%E8%99%AB%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫概念："><a href="#爬虫概念：" class="headerlink" title="爬虫概念："></a>爬虫概念：</h1><p>编写一段自动抓取互联网信息的程序，从互联网上抓取对于我们有价值的信息。</p><p>爬虫，无非就是模拟用户点击，编写爬虫可以更加方便的收集信息。</p><p>在做安全开发的时候，我们也可以编写特定的扫描工具进行网站的勘察，亦或者信息收集。</p><h2 id="新闻类爬虫的功能实现："><a href="#新闻类爬虫的功能实现：" class="headerlink" title="新闻类爬虫的功能实现："></a>新闻类爬虫的功能实现：</h2><h3 id="目标要求：爬取光明新闻网的链接、标题、时间。"><a href="#目标要求：爬取光明新闻网的链接、标题、时间。" class="headerlink" title="目标要求：爬取光明新闻网的链接、标题、时间。"></a>目标要求：爬取光明新闻网的链接、标题、时间。</h3><h3 id="核心内容方法："><a href="#核心内容方法：" class="headerlink" title="核心内容方法："></a>核心内容方法：</h3><h4 id="1、使用python中的request库，request-get-url-，获取网站中的内容。"><a href="#1、使用python中的request库，request-get-url-，获取网站中的内容。" class="headerlink" title="1、使用python中的request库，request.get(url)，获取网站中的内容。"></a>1、使用python中的request库，request.get(url)，获取网站中的内容。</h4><p>注：爬取到的中文网需使用“utf-8”转码，否则作为页面会出现乱码问题，初学者容易遇到的坑。</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/17/eaf4dda3ab5e1db1.png" class="lazyload placeholder" data-srcset="https://s3.bmp.ovh/imgs/2022/04/17/eaf4dda3ab5e1db1.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220414160627954">)</p><h4 id="2、使用正则表达式进行页面内容匹配。"><a href="#2、使用正则表达式进行页面内容匹配。" class="headerlink" title="2、使用正则表达式进行页面内容匹配。"></a>2、使用正则表达式进行页面内容匹配。</h4><p>如：d &#x3D; r’href&#x3D;(.*?)target&#x3D;_blank’</p><p>​gcbt1 &#x3D; re.findall(m,gclj1)</p><p>此时则代表匹配href&#x3D; 与target&#x3D;_blank之间的内容</p><p>使用该语法及正则函数我们就可以逐步匹配到我们想要等等内容。</p><p>如图：</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/17/78946de9d73d2303.png" class="lazyload placeholder" data-srcset="https://s3.bmp.ovh/imgs/2022/04/17/78946de9d73d2303.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220414161214403">)</p><h4 id="4、数据处理"><a href="#4、数据处理" class="headerlink" title="4、数据处理"></a>4、数据处理</h4><p>​爬取到数据之后我们要做到就是对数据进行处理然后输出。由于findall方法正则出来的内容一般都是储存在list里面。我们使用str()强制转换将list列表转化为str()字符串。注：此时如果将list字符串遍历输出到str中可能会更加合理。</p><p>由于使用了强制转换，输出的数据会存在不规范等问题。此处出现了将两个列表的元素融合，使用split分割符将元素分割开来。</p><p>如图：<img src="https://s3.bmp.ovh/imgs/2022/04/17/66e0c89dd54c1474.png" class="lazyload placeholder" data-srcset="https://s3.bmp.ovh/imgs/2022/04/17/66e0c89dd54c1474.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220414172301929">)</p><p>在使用时我们可以将爬取的数据储存到excel表里面。</p><p>此时使用“xlwt”库来写入excel文件。</p><p>注意：此次在用xlwt库大量写入excel表格时会出现内存占用的报错。这里我使用的方法是使用延时写入，避免报错。</p><p>最后保存excel表格，我们就完成了网页内容的爬取。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Socket编程学习笔记（python）</title>
      <link href="/2022/04/12/socket%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/04/12/socket%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Socket？？？："><a href="#Socket？？？：" class="headerlink" title="Socket？？？："></a>Socket？？？：</h1><p>基于TCP的应用层与运输层之间的抽象层</p><p> <img src="https://s3.bmp.ovh/imgs/2022/04/17/5a7d6e9faca636c1.png" class="lazyload placeholder" data-srcset="https://s3.bmp.ovh/imgs/2022/04/17/5a7d6e9faca636c1.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220414110508971"></p><p>利用socket，我们可以发送文件，图片，消息。当然，你也可以利用socket协议发送一些不可名状的东西，socket木马编写（坏笑~~）</p><h2 id="话不多说，具体应用实现："><a href="#话不多说，具体应用实现：" class="headerlink" title="话不多说，具体应用实现："></a>话不多说，具体应用实现：</h2><p><img src="https://s3.bmp.ovh/imgs/2022/04/17/6e401f27e2bd1a23.png" class="lazyload placeholder" data-srcset="https://s3.bmp.ovh/imgs/2022/04/17/6e401f27e2bd1a23.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220414111450791"></p><p><img src="https://s3.bmp.ovh/imgs/2022/04/17/8acb7e2abddd1144.png" class="lazyload placeholder" data-srcset="https://s3.bmp.ovh/imgs/2022/04/17/8acb7e2abddd1144.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220414111523224"></p><p>可以看到，socket需要客户端和服务端两个程序，此时我们使用python调用socke库，使用TCP协议，然后再进行绑定端口设置监听操作。为方便程序交互我们设置了一些提示，并且将数据进行编码发送。</p><p>补充在python中socket的一些函数方法：</p><h2 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h2><h3 id="服务端socket函数"><a href="#服务端socket函数" class="headerlink" title="服务端socket函数"></a>服务端socket函数</h3><p>　　　　s.bind(address)：将套接字绑定到地址，在AF_INET下，以tuple(host,prot)的方式传入，如s.bind((host,port))。</p><p>　　　　s.listen(backlog)：开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值最少为1。</p><p>　　　　s.accept()：接受TCP连接并返回(conn,address)，其中conn是新的套接字对象，可以用来接收和发送数据，address是连接客户端的地址。(sock,addr &#x3D; s.accept)。</p><h3 id="客户端socket函数"><a href="#客户端socket函数" class="headerlink" title="客户端socket函数"></a>客户端socket函数</h3><p>　　　　s.connect(address)：链接到address处的套接字，一般address的格式为tuple(host,port),如果链接出错，则返回socket.error错误。</p><p>　　　　s.connect_ex(address)：功能与s.connect(address)相同，但成功返回0，失败返回errno的值。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
